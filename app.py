import streamlit as st
from io import BytesIO
import hashlib
import time
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import threading
import base64
from fpdf import FPDF
import random
from dotenv import load_dotenv
load_dotenv()  # Load environment variables
import tempfile
import os
import urllib.parse
from gtts import gTTS

# --- Custom Modules ---
from pdf_utils import extract_text_chunks
from embed_utils import build_faiss_index, search
from qa_engine import generate_answer

# --- Page Config ---
st.set_page_config(page_title="üìö StudyMate ‚Äì AI PDF Q&A", layout="wide")

# --- Load External CSS ---
def load_css():
    try:
        with open("styles.css", "r") as f:
            st.markdown(f"<style>{f.read()}</style>", unsafe_allow_html=True)
    except FileNotFoundError:
        st.error("CSS file not found. Please make sure styles.css exists.")

load_css()

# --- Text-to-Speech Function ---
def text_to_speech(text):
    """Convert text to speech and return audio file"""
    try:
        # Optimize text length for faster processing
        max_chars = 800
        if len(text) > max_chars:
            # Find last complete sentence within limit
            truncated = text[:max_chars]
            last_period = truncated.rfind('.')
            if last_period > max_chars * 0.7:
                text = truncated[:last_period + 1]
            else:
                text = truncated + "..."
        
        # Generate TTS
        tts = gTTS(text=text, lang='en', slow=False)
        
        # Create temporary file
        with tempfile.NamedTemporaryFile(delete=False, suffix='.mp3') as tmp_file:
            tts.save(tmp_file.name)
            return tmp_file.name
            
    except Exception as e:
        st.error(f"Text-to-speech error: {str(e)}")
        return None

# --- Share Functions ---
def generate_share_content(question, answer):
    """Generate content for sharing"""
    share_text = f"üìö StudyMate Q&A\n\n‚ùì Question: {question}\n\n‚úÖ Answer: {answer[:500]}{'...' if len(answer) > 500 else ''}\n\nü§ñ Generated by StudyMate AI"
    return share_text

def create_share_links(question, answer):
    """Create sharing links for various platforms"""
    share_content = generate_share_content(question, answer)
    encoded_content = urllib.parse.quote(share_content)
    
    links = {
        "WhatsApp": f"https://wa.me/?text={encoded_content}",
        "Email": f"mailto:?subject=StudyMate Q&A - {question[:30]}...&body={encoded_content}",
        "Twitter": f"https://twitter.com/intent/tweet?text={encoded_content}",
        "LinkedIn": f"https://www.linkedin.com/sharing/share-offsite/?url=&summary={encoded_content}",
        "Telegram": f"https://t.me/share/url?url=&text={encoded_content}"
    }
    
    return links

# --- Scroll to Top Function ---
def scroll_to_top():
    """Scroll to top of page"""
    st.markdown("""
    <script>
        setTimeout(() => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }, 300);
    </script>
    """, unsafe_allow_html=True)

# --- PDF Generation Function ---
def create_pdf(answer, question, timestamp):
    """Create a PDF document from the answer"""
    pdf = FPDF()
    pdf.add_page()
    
    # Set font
    pdf.set_font("Arial", 'B', 16)
    
    # Title (without emoji)
    pdf.cell(200, 10, txt="StudyMate - AI PDF Q&A", ln=True, align='C')
    pdf.ln(10)
    
    # Question
    pdf.set_font("Arial", 'B', 14)
    pdf.cell(200, 10, txt="Question:", ln=True)
    pdf.set_font("Arial", '', 12)
    
    # Clean question from emojis and markdown
    clean_question = clean_text_for_pdf(question)
    pdf.multi_cell(0, 10, txt=clean_question)
    pdf.ln(5)
    
    # Timestamp
    pdf.set_font("Arial", 'I', 10)
    pdf.cell(0, 10, txt=f"Generated on: {timestamp}", ln=True)
    pdf.ln(10)
    
    # Answer
    pdf.set_font("Arial", 'B', 14)
    pdf.cell(200, 10, txt="Answer:", ln=True)
    pdf.set_font("Arial", '', 12)
    
    # Clean and format the answer for PDF
    clean_answer = clean_text_for_pdf(answer)
    pdf.multi_cell(0, 8, txt=clean_answer)
    
    # Footer
    pdf.ln(20)
    pdf.set_font("Arial", 'I', 10)
    pdf.cell(0, 10, txt="Generated by StudyMate AI - Your Personal Study Assistant", ln=True, align='C')
    
    return pdf.output(dest='S').encode('latin1')

def clean_text_for_pdf(text):
    """Remove emojis and markdown formatting for PDF"""
    # Remove emojis and special characters
    text = text.encode('ascii', 'ignore').decode('ascii')
    # Remove markdown formatting
    text = text.replace('**', '').replace('#', '').replace('##', '').replace('###', '')
    text = text.replace('*', '').replace('_', '').replace('`', '')
    return text

# --- Image Processing Functions ---
def process_image_file(image_file):
    """Process uploaded image file"""
    try:
        return f"Image content: This image '{image_file.name}' contains visual study material information."
    except Exception as e:
        return f"Error processing image: {str(e)}"

# --- Quiz Generation Functions ---
def generate_quiz_questions(context, num_questions=5):
    """Generate multiple choice quiz questions based on the context"""
    questions = []
    
    # Extract key concepts for quiz generation
    key_terms = extract_key_terms_from_context(context)
    
    if not key_terms:
        return questions
    
    # Generate multiple choice questions
    for i in range(min(num_questions, len(key_terms))):
        term = key_terms[i]
        
        question_data = {
            'question': f"What is the primary concept of '{term}'?",
            'options': [
                f"Basic definition and fundamental principles of {term}",
                f"Advanced technical applications of {term}",
                f"Historical development and evolution of {term}",
                f"Practical implementation and case studies of {term}"
            ],
            'correct_answer': 0,
            'user_answer': None,
            'explanation': f"This question tests your understanding of the core concept of {term} as discussed in the study material."
        }
        questions.append(question_data)
    
    return questions[:num_questions]

def extract_key_terms_from_context(context):
    """Extract key terms from context for quiz generation"""
    words = context.split()
    key_terms = []
    
    # Look for important terms (nouns, capitalized words, etc.)
    for word in words:
        if (len(word) > 5 and word[0].isupper() and 
            word.lower() not in ['the', 'and', 'for', 'with', 'that', 'this']):
            clean_word = word.strip('.,!?;:"()[]{}')
            if len(clean_word) > 3:
                key_terms.append(clean_word)
    
    return list(set(key_terms))[:5]

# --- Clean Header ---
st.markdown("<h1>üìö StudyMate ‚Äì AI PDF Q&A</h1>", unsafe_allow_html=True)

# --- Session State Init ---
if "qa_history" not in st.session_state:
    st.session_state.qa_history = []
if "chunks_cache" not in st.session_state:
    st.session_state.chunks_cache = {}
if "index_data" not in st.session_state:
    st.session_state.index_data = None
if "current_answer" not in st.session_state:
    st.session_state.current_answer = None
if "current_question" not in st.session_state:
    st.session_state.current_question = None
if "processing_complete" not in st.session_state:
    st.session_state.processing_complete = False
if "preloaded" not in st.session_state:
    st.session_state.preloaded = False
if "quiz_questions" not in st.session_state:
    st.session_state.quiz_questions = []
if "show_quiz" not in st.session_state:
    st.session_state.show_quiz = False
if "current_context" not in st.session_state:
    st.session_state.current_context = ""
if "quiz_submitted" not in st.session_state:
    st.session_state.quiz_submitted = False
if "scroll_to_quiz" not in st.session_state:
    st.session_state.scroll_to_quiz = False
if "uploaded_images" not in st.session_state:
    st.session_state.uploaded_images = []
if "show_share_options" not in st.session_state:
    st.session_state.show_share_options = False
if "audio_file" not in st.session_state:
    st.session_state.audio_file = None
if "current_audio_text" not in st.session_state:
    st.session_state.current_audio_text = ""
if "generating_audio" not in st.session_state:
    st.session_state.generating_audio = False

# --- Preload models in background ---
def preload_models():
    if not st.session_state.preloaded:
        try:
            from embed_utils import model
            dummy_embedding = model.encode(["warmup text"], show_progress_bar=False)
            st.session_state.preloaded = True
        except:
            pass

if not st.session_state.preloaded:
    threading.Thread(target=preload_models, daemon=True).start()

# --- File Hashing ---
def get_file_hash(file_bytes):
    return hashlib.md5(file_bytes.getvalue()).hexdigest()

# --- Processing Functions ---
@st.cache_data(show_spinner=False, max_entries=10, ttl=3600)
def get_chunks_fast(file_bytes):
    return extract_text_chunks(file_bytes, chunk_size=300)

@st.cache_resource(show_spinner=False, max_entries=5)
def get_index_fast(chunks):
    if not chunks or len(chunks) == 0:
        return None
    return build_faiss_index(chunks)

def process_files_fast(files):
    all_chunks = []
    
    with ThreadPoolExecutor(max_workers=min(4, len(files))) as executor:
        futures = []
        for file in files:
            file_bytes = BytesIO(file.read())
            file_hash = get_file_hash(file_bytes)
            
            if file_hash not in st.session_state.chunks_cache:
                futures.append(executor.submit(get_chunks_fast, file_bytes))
            else:
                all_chunks.extend(st.session_state.chunks_cache[file_hash])
        
        for future in futures:
            chunks = future.result()
            if chunks:
                all_chunks.extend(chunks)
                file_hash = get_file_hash(BytesIO(file.getvalue()))
                st.session_state.chunks_cache[file_hash] = chunks
    
    return all_chunks

def process_images_fast(images):
    """Process images in parallel"""
    image_texts = []
    
    with ThreadPoolExecutor(max_workers=min(4, len(images))) as executor:
        futures = [executor.submit(process_image_file, image) for image in images]
        
        for future in futures:
            try:
                image_text = future.result()
                image_texts.append(image_text)
            except Exception as e:
                image_texts.append(f"Error processing image: {str(e)}")
    
    return image_texts

def build_index_async(chunks):
    if chunks and not st.session_state.index_data:
        st.session_state.index_data = get_index_fast(chunks)

# --- Display Loading Animation ---
def show_loading_animation():
    return st.markdown("""
    <div class="loading-container">
        <div class="book-loader">
            <div class="book"></div>
            <div class="book"></div>
            <div class="book"></div>
            <div class="book"></div>
            <div class="book"></div>
        </div>
        <div class="loading-text">Analyzing your study materials</div>
        <div class="loading-dots">
            <div class="dot"></div>
            <div class="dot"></div>
            <div class="dot"></div>
        </div>
    </div>
    """, unsafe_allow_html=True)

# --- Display Answer with Audio Button ---
def display_answer_with_features(text, question, context):
    st.session_state.current_context = context
    st.session_state.current_audio_text = text
    
    # Scroll to top when answer appears
    scroll_to_top()
    
    # Display the answer
    st.markdown(f'''
    <div class="answer-box" id="answer-section">
        <div class="answer-header">üìñ Your Answer</div>
        <div class="answer-content">
            {text}
        </div>
    </div>
    ''', unsafe_allow_html=True)
    
    # Audio section with button
    st.markdown("### üîä Audio Answer")
    
    # Audio button and player in columns
    audio_col1, audio_col2 = st.columns([1, 3])
    
    with audio_col1:
        if st.button("üéµ Generate Audio", 
                     use_container_width=True, 
                     key="generate_audio_btn",
                     disabled=st.session_state.generating_audio):
            st.session_state.generating_audio = True
            st.rerun()
    
    # Generate audio if the flag is set
    if st.session_state.generating_audio:
        with st.spinner("Generating audio..."):
            audio_file = text_to_speech(text)
            if audio_file:
                # Clean up previous audio file
                if st.session_state.audio_file and os.path.exists(st.session_state.audio_file):
                    os.unlink(st.session_state.audio_file)
                st.session_state.audio_file = audio_file
            st.session_state.generating_audio = False
            st.rerun()
    
    with audio_col2:
        # Display audio player if audio file exists
        if st.session_state.audio_file and os.path.exists(st.session_state.audio_file):
            with open(st.session_state.audio_file, "rb") as audio:
                audio_bytes = audio.read()
                st.audio(audio_bytes, format="audio/mp3")
        elif st.session_state.generating_audio:
            st.info("Generating audio...")
        else:
            st.info("Click 'Generate Audio' to create audio version of the answer")
    
    # Action buttons in columns
    col1, col2, col3 = st.columns([1, 1, 1])
    
    # Download PDF
    with col1:
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        filename = f"studymate_answer_{timestamp}.pdf"
        
        try:
            pdf_data = create_pdf(text, question, datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
            
            st.download_button(
                label="üì• Download PDF",
                data=pdf_data,
                file_name=filename,
                mime="application/pdf",
                help="Download answer as PDF",
                key="download_pdf_main",
                use_container_width=True
            )
        except Exception as e:
            st.error(f"Error creating PDF: {str(e)}")
    
    # Share Options
    with col2:
        if st.button("üì§ Share Answer", use_container_width=True, key="share_btn"):
            st.session_state.show_share_options = True
    
    # Quiz Button
    with col3:
        if st.button("üéØ Take Quiz", use_container_width=True, key="take_quiz_btn"):
            st.session_state.show_quiz = True
            st.session_state.quiz_submitted = False
            st.session_state.quiz_questions = generate_quiz_questions(context, 5)
            st.session_state.scroll_to_quiz = True
            st.rerun()
    
    # Share options display
    if hasattr(st.session_state, 'show_share_options') and st.session_state.show_share_options:
        st.markdown("### üì§ Share Options")
        share_links = create_share_links(question, text)
        
        share_cols = st.columns(5)
        share_platforms = ["WhatsApp", "Email", "Twitter", "LinkedIn", "Telegram"]
        share_emojis = ["üì±", "‚úâÔ∏è", "üê¶", "üíº", "üì®"]
        
        for i, (platform, emoji) in enumerate(zip(share_platforms, share_emojis)):
            with share_cols[i]:
                st.markdown(f'<a href="{share_links[platform]}" target="_blank" style="text-decoration: none;"><button style="width: 100%; padding: 10px; border: none; border-radius: 5px; background-color: #ff4b4b; color: white; cursor: pointer;">{emoji} {platform}</button></a>', unsafe_allow_html=True)
        
        if st.button("‚úñÔ∏è Close Share Options", key="close_share_btn"):
            st.session_state.show_share_options = False
            st.rerun()
    
    st.session_state.current_answer = text
    st.session_state.current_question = question
    st.session_state.processing_complete = True

# --- Display Quiz ---
def display_quiz():
    # Scroll to top for quiz
    scroll_to_top()
    
    st.markdown("### üéØ Quiz Time!")
    st.info("Test your understanding with these multiple choice questions:")
    
    for i, q in enumerate(st.session_state.quiz_questions, 1):
        st.markdown(f"**Q{i}:** {q['question']}")
        
        # Display options
        option_key = f"quiz_{i}"
        if st.session_state.quiz_submitted:
            # Show results after submission
            user_answer = q['user_answer']
            correct_answer = q['correct_answer']
            
            for j, option in enumerate(q['options']):
                if j == correct_answer:
                    st.success(f"‚úÖ {option}")
                    st.info(f"**Explanation:** {q['explanation']}")
                elif j == user_answer:
                    st.error(f"‚ùå {option}")
                else:
                    st.write(f"‚óã {option}")
            st.markdown("---")
        else:
            # Interactive options before submission
            selected_option = st.radio(
                f"Select your answer for Q{i}:",
                q['options'],
                key=f"option_{i}",
                index=None
            )
            if selected_option:
                q['user_answer'] = q['options'].index(selected_option)
            st.markdown("---")
    
    if not st.session_state.quiz_submitted:
        col1, col2, col3 = st.columns([1, 2, 1])
        with col2:
            if st.button("‚úÖ Submit Quiz", type="primary", use_container_width=True, key="submit_quiz_btn"):
                st.session_state.quiz_submitted = True
                st.session_state.scroll_to_quiz = True
                st.rerun()
    
    if st.session_state.quiz_submitted:
        # Calculate score
        correct_answers = sum(1 for q in st.session_state.quiz_questions 
                            if q['user_answer'] == q['correct_answer'])
        total_questions = len(st.session_state.quiz_questions)
        score_percent = (correct_answers / total_questions) * 100
        
        # Display progress bar for score
        st.markdown("### üìä Quiz Results")
        st.progress(score_percent / 100)
        st.markdown(f"**Score: {correct_answers}/{total_questions} ({score_percent:.1f}%)**")
        
        if score_percent >= 80:
            st.success("üéâ Excellent! You have mastered this topic!")
        elif score_percent >= 60:
            st.warning("üëç Good effort! You understand the main concepts well.")
        else:
            st.info("üìö Keep studying! Review the material and try the quiz again.")
        
        st.markdown("---")
    
    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        if st.button("‚Üê Back to Answer", use_container_width=True, key="back_to_answer_btn"):
            st.session_state.show_quiz = False
            st.session_state.quiz_submitted = False
            st.rerun()

# --- Upload Section ---
st.markdown("### üìÅ Upload Your Study Materials")

# File type selection
file_type = st.radio(
    "Select file type to upload:",
    ["PDF Documents", "Images"],
    horizontal=True,
    key="file_type_selector"
)

uploaded_files = None
uploaded_images = None

if file_type == "PDF Documents":
    uploaded_files = st.file_uploader(
        "üìÇ Upload PDF files",
        type="pdf",
        accept_multiple_files=True,
        help="Upload one or multiple PDF files for analysis."
    )
else:
    uploaded_images = st.file_uploader(
        "üñºÔ∏è Upload images",
        type=["png", "jpg", "jpeg", "bmp", "tiff"],
        accept_multiple_files=True,
        help="Upload one or multiple images for analysis."
    )

# Question input and submit button side by side
col1, col2 = st.columns([4, 1])
with col1:
    question = st.text_area("üí° Ask a question about your materials", height=100, key="question_input")
with col2:
    st.markdown("<br>", unsafe_allow_html=True)  # Add spacing
    submitted = st.button("üöÄ Submit", use_container_width=True, type="primary", key="submit_btn")

# --- Main Logic ---
if submitted and question:
    # Validation check
    if file_type == "PDF Documents" and not uploaded_files:
        st.error("Please upload at least one PDF file.")
        st.stop()
    elif file_type == "Images" and not uploaded_images:
        st.error("Please upload at least one image.")
        st.stop()
    
    st.session_state.processing_complete = False
    st.session_state.show_quiz = False
    st.session_state.quiz_submitted = False
    st.session_state.scroll_to_quiz = False
    st.session_state.show_share_options = False
    st.session_state.generating_audio = False
    
    # Clean up previous audio
    if st.session_state.audio_file and os.path.exists(st.session_state.audio_file):
        os.unlink(st.session_state.audio_file)
    st.session_state.audio_file = None
    
    loading_placeholder = st.empty()
    loading_placeholder.markdown("<div id='loading-animation'></div>", unsafe_allow_html=True)
    show_loading_animation()
    
    try:
        all_chunks = []
        
        # Process files based on selected type
        if file_type == "PDF Documents" and uploaded_files:
            pdf_chunks = process_files_fast(uploaded_files)
            all_chunks.extend(pdf_chunks)
        
        elif file_type == "Images" and uploaded_images:
            with st.spinner("üñºÔ∏è Processing images..."):
                image_texts = process_images_fast(uploaded_images)
                all_chunks.extend(image_texts)
        
        if all_chunks:
            build_index_async(all_chunks)
            
            if st.session_state.index_data:
                index, embeddings, chunk_list = st.session_state.index_data
                relevant_chunks = search(question, index, chunk_list, embeddings, top_k=5)
                answer = generate_answer(relevant_chunks, question)
                
                st.session_state.qa_history.append({
                    "question": question,
                    "answer": answer,
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                })

                # Clear loading animation FIRST
                loading_placeholder.empty()
                
                # Then display answer
                context = "\n".join(relevant_chunks[:3])
                display_answer_with_features(answer, question, context)
                
                st.balloons()
            else:
                loading_placeholder.empty()
                st.error("Failed to build search index. Please try again.")
        else:
            loading_placeholder.empty()
            st.error("No content could be extracted from the uploaded files.")
    
    except Exception as e:
        loading_placeholder.empty()
        st.error(f"Error processing your request: {str(e)}")

elif st.session_state.show_quiz and st.session_state.quiz_questions:
    display_quiz()

elif st.session_state.processing_complete and st.session_state.current_answer:
    context = st.session_state.current_context
    display_answer_with_features(st.session_state.current_answer, st.session_state.current_question, context)

# --- Sidebar: Q&A History ---
with st.sidebar:
    st.markdown("### üß† Q&A History")
    if st.session_state.qa_history:
        for i, entry in enumerate(reversed(st.session_state.qa_history[-5:]), 1):
            with st.expander(f"{i}. {entry['question'][:50]}..."):
                st.markdown(f"**Answer:** {entry['answer']}")
                st.markdown(f"_Asked on: {entry['timestamp']}_")
        if st.button("üßπ Clear History"):
            # Clean up audio files during history clear
            if st.session_state.audio_file and os.path.exists(st.session_state.audio_file):
                os.unlink(st.session_state.audio_file)
            
            st.session_state.qa_history = []
            st.session_state.current_answer = None
            st.session_state.current_question = None
            st.session_state.processing_complete = False
            st.session_state.quiz_questions = []
            st.session_state.show_quiz = False
            st.session_state.quiz_submitted = False
            st.session_state.scroll_to_quiz = False
            st.session_state.uploaded_images = []
            st.session_state.show_share_options = False
            st.session_state.audio_file = None
            st.session_state.current_audio_text = ""
            st.session_state.generating_audio = False
            st.rerun()
    else:
        st.info("No Q&A history yet.")

# Clean up audio files on app restart
if st.session_state.audio_file and not st.session_state.current_audio_text:
    if os.path.exists(st.session_state.audio_file):
        os.unlink(st.session_state.audio_file)
    st.session_state.audio_file = None
